// Generated by delombok at Thu Feb 13 14:20:21 UTC 2025
package io.github.humbleui.skija;

import java.util.Objects;
import io.github.humbleui.types.*;

public class PathSegment {
    public final PathVerb _verb;
    public final Point _p0;
    public final Point _p1;
    public final Point _p2;
    public final Point _p3;
    public final float _conicWeight;
    public final boolean _closeLine;
    public final boolean _closedContour;

    public PathSegment() {
        this(PathVerb.DONE, null, null, null, null, 0.0F, false, false);
    }

    public PathSegment(int verbOrdinal, float x0, float y0, boolean isClosedContour) {
        this(PathVerb._values[verbOrdinal], new Point(x0, y0), null, null, null, 0.0F, false, isClosedContour);
        assert verbOrdinal == PathVerb.MOVE.ordinal() || verbOrdinal == PathVerb.CLOSE.ordinal()
                : "Expected MOVE or CLOSE, got " + PathVerb._values[verbOrdinal];
    }

    public PathSegment(float x0, float y0, float x1, float y1, boolean isCloseLine, boolean isClosedContour) {
        this(PathVerb.LINE, new Point(x0, y0), new Point(x1, y1), null, null, 0.0F, isCloseLine, isClosedContour);
    }

    public PathSegment(float x0, float y0, float x1, float y1, float x2, float y2, boolean isClosedContour) {
        this(PathVerb.QUAD, new Point(x0, y0), new Point(x1, y1), new Point(x2, y2), null, 0.0F, false,
                isClosedContour);
    }

    public PathSegment(float x0, float y0, float x1, float y1, float x2, float y2, float conicWeight,
            boolean isClosedContour) {
        this(PathVerb.CONIC, new Point(x0, y0), new Point(x1, y1), new Point(x2, y2), null, conicWeight, false,
                isClosedContour);
    }

    public PathSegment(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3,
            boolean isClosedContour) {
        this(PathVerb.CUBIC, new Point(x0, y0), new Point(x1, y1), new Point(x2, y2), new Point(x3, y3), 0.0F, false,
                isClosedContour);
    }

    @Override
    public String toString() {
        return "Segment(" + "verb=" + _verb + (_verb != PathVerb.DONE ? ", p0=" + _p0 : "")
                + (_verb == PathVerb.LINE || _verb == PathVerb.QUAD || _verb == PathVerb.CONIC
                        || _verb == PathVerb.CUBIC ? ", p1=" + _p1 : "")
                + (_verb == PathVerb.QUAD || _verb == PathVerb.CONIC || _verb == PathVerb.CUBIC ? ", p2=" + _p2 : "")
                + (_verb == PathVerb.CUBIC ? ", p3=" + _p3 : "")
                + (_verb == PathVerb.CONIC ? ", conicWeight=" + _conicWeight : "")
                + (_verb == PathVerb.LINE ? ", closeLine=" + _closeLine : "")
                + (_verb != PathVerb.DONE ? ", closedContour=" + _closedContour : "") + ")";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        PathSegment segment = (PathSegment) o;
        return _verb == segment._verb && (_verb != PathVerb.DONE ? Objects.equals(_p0, segment._p0) : true)
                && (_verb == PathVerb.LINE || _verb == PathVerb.QUAD || _verb == PathVerb.CONIC
                        || _verb == PathVerb.CUBIC ? Objects.equals(_p1, segment._p1) : true)
                && (_verb == PathVerb.QUAD || _verb == PathVerb.CONIC || _verb == PathVerb.CUBIC
                        ? Objects.equals(_p2, segment._p2)
                        : true)
                && (_verb == PathVerb.CUBIC ? Objects.equals(_p3, segment._p3) : true)
                && (_verb == PathVerb.CONIC ? Float.compare(segment._conicWeight, _conicWeight) == 0 : true)
                && (_verb == PathVerb.LINE ? _closeLine == segment._closeLine : true)
                && (_verb != PathVerb.DONE ? _closedContour == segment._closedContour : true);
    }

    @Override
    public int hashCode() {
        switch (_verb) {
            case DONE:
                return Objects.hash(_verb);
            case MOVE:
                return Objects.hash(_verb, _p0, _closedContour);
            case LINE:
                return Objects.hash(_verb, _p0, _p1, _closeLine, _closedContour);
            case QUAD:
                return Objects.hash(_verb, _p0, _p1, _p2, _closedContour);
            case CONIC:
                return Objects.hash(_verb, _p0, _p1, _p2, _conicWeight, _closedContour);
            case CUBIC:
                return Objects.hash(_verb, _p0, _p1, _p2, _p3, _closedContour);
            default:
                throw new RuntimeException("Unreachable");
        }
    }

    @SuppressWarnings("all")
    public PathSegment(final PathVerb verb, final Point p0, final Point p1, final Point p2, final Point p3,
            final float conicWeight, final boolean closeLine, final boolean closedContour) {
        this._verb = verb;
        this._p0 = p0;
        this._p1 = p1;
        this._p2 = p2;
        this._p3 = p3;
        this._conicWeight = conicWeight;
        this._closeLine = closeLine;
        this._closedContour = closedContour;
    }

    @SuppressWarnings("all")
    public PathVerb getVerb() {
        return this._verb;
    }

    @SuppressWarnings("all")
    public Point getP0() {
        return this._p0;
    }

    @SuppressWarnings("all")
    public Point getP1() {
        return this._p1;
    }

    @SuppressWarnings("all")
    public Point getP2() {
        return this._p2;
    }

    @SuppressWarnings("all")
    public Point getP3() {
        return this._p3;
    }

    @SuppressWarnings("all")
    public float getConicWeight() {
        return this._conicWeight;
    }

    @SuppressWarnings("all")
    public boolean isCloseLine() {
        return this._closeLine;
    }

    @SuppressWarnings("all")
    public boolean isClosedContour() {
        return this._closedContour;
    }
}

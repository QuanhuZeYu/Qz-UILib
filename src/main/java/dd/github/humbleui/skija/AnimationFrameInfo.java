// Generated by delombok at Thu Feb 13 14:20:21 UTC 2025
package io.github.humbleui.skija;

import io.github.humbleui.types.IRect;
import org.jetbrains.annotations.ApiStatus;

/**
 * Information about individual frames in a multi-framed image.
 */
public class AnimationFrameInfo {
    @ApiStatus.Internal
    public AnimationFrameInfo(int requiredFrame, int duration, boolean fullyReceived, int alphaTypeOrdinal,
            boolean hasAlphaWithinBounds, int disposalMethodOrdinal, int blendModeOrdinal, IRect frameRect) {
        this(requiredFrame, duration, fullyReceived, ColorAlphaType._values[alphaTypeOrdinal], hasAlphaWithinBounds,
                AnimationDisposalMode._values[disposalMethodOrdinal], BlendMode._values[blendModeOrdinal], frameRect);
    }

    /**
     * <p>
     * The frame that this frame needs to be blended with, or
     * -1 if this frame is independent (so it can be
     * drawn over an uninitialized buffer).
     * </p>
     *
     * <p>
     * Note that this is the *earliest* frame that can be used
     * for blending. Any frame from [_requiredFrame, i) can be
     * used, unless its getDisposalMethod() is
     * {@link AnimationDisposalMode#RESTORE_PREVIOUS}.
     * </p>
     */
    @ApiStatus.Internal
    public int _requiredFrame;
    /**
     * Number of milliseconds to show this frame.
     */
    @ApiStatus.Internal
    public int _duration;
    /**
     * <p>
     * Whether the end marker for this frame is contained in the stream.
     * </p>
     *
     * <p>
     * Note: this does not guarantee that an attempt to decode will be complete.
     * There could be an error in the stream.
     * </p>
     */
    @ApiStatus.Internal
    public boolean _fullyReceived;
    /**
     * <p>
     * This is conservative; it will still return non-opaque if e.g. a
     * color index-based frame has a color with alpha but does not use it.
     * </p>
     */
    @ApiStatus.Internal
    public ColorAlphaType _alphaType;
    /**
     * <p>
     * Whether the updated rectangle contains alpha.
     * </p>
     *
     * <p>
     * This is conservative; it will still be set to true if e.g. a color
     * index-based frame has a color with alpha but does not use it. In
     * addition, it may be set to true, even if the final frame, after
     * blending, is opaque.
     * </p>
     */
    @ApiStatus.Internal
    public boolean _hasAlphaWithinBounds;
    /**
     * <p>
     * How this frame should be modified before decoding the next one.
     * </p>
     */
    @ApiStatus.Internal
    public AnimationDisposalMode _disposalMethod;
    /**
     * <p>
     * How this frame should blend with the prior frame.
     * </p>
     */
    @ApiStatus.Internal
    public BlendMode _blendMode;
    /**
     * <p>
     * The rectangle updated by this frame.
     * </p>
     *
     * <p>
     * It may be empty, if the frame does not change the image. It will
     * always be contained by {@link Codec#getSize()}.
     */
    @ApiStatus.Internal
    public IRect _frameRect;

    /**
     * <p>
     * The frame that this frame needs to be blended with, or
     * -1 if this frame is independent (so it can be
     * drawn over an uninitialized buffer).
     * </p>
     *
     * <p>
     * Note that this is the *earliest* frame that can be used
     * for blending. Any frame from [_requiredFrame, i) can be
     * used, unless its getDisposalMethod() is
     * {@link AnimationDisposalMode#RESTORE_PREVIOUS}.
     * </p>
     */
    @SuppressWarnings("all")
    public int getRequiredFrame() {
        return this._requiredFrame;
    }

    /**
     * Number of milliseconds to show this frame.
     */
    @SuppressWarnings("all")
    public int getDuration() {
        return this._duration;
    }

    /**
     * <p>
     * Whether the end marker for this frame is contained in the stream.
     * </p>
     *
     * <p>
     * Note: this does not guarantee that an attempt to decode will be complete.
     * There could be an error in the stream.
     * </p>
     */
    @SuppressWarnings("all")
    public boolean isFullyReceived() {
        return this._fullyReceived;
    }

    /**
     * <p>
     * This is conservative; it will still return non-opaque if e.g. a
     * color index-based frame has a color with alpha but does not use it.
     * </p>
     */
    @SuppressWarnings("all")
    public ColorAlphaType getAlphaType() {
        return this._alphaType;
    }

    /**
     * <p>
     * Whether the updated rectangle contains alpha.
     * </p>
     *
     * <p>
     * This is conservative; it will still be set to true if e.g. a color
     * index-based frame has a color with alpha but does not use it. In
     * addition, it may be set to true, even if the final frame, after
     * blending, is opaque.
     * </p>
     */
    @SuppressWarnings("all")
    public boolean isHasAlphaWithinBounds() {
        return this._hasAlphaWithinBounds;
    }

    /**
     * <p>
     * How this frame should be modified before decoding the next one.
     * </p>
     */
    @SuppressWarnings("all")
    public AnimationDisposalMode getDisposalMethod() {
        return this._disposalMethod;
    }

    /**
     * <p>
     * How this frame should blend with the prior frame.
     * </p>
     */
    @SuppressWarnings("all")
    public BlendMode getBlendMode() {
        return this._blendMode;
    }

    /**
     * <p>
     * The rectangle updated by this frame.
     * </p>
     *
     * <p>
     * It may be empty, if the frame does not change the image. It will
     * always be contained by {@link Codec#getSize()}.
     */
    @SuppressWarnings("all")
    public IRect getFrameRect() {
        return this._frameRect;
    }

    /**
     * <p>
     * The frame that this frame needs to be blended with, or
     * -1 if this frame is independent (so it can be
     * drawn over an uninitialized buffer).
     * </p>
     *
     * <p>
     * Note that this is the *earliest* frame that can be used
     * for blending. Any frame from [_requiredFrame, i) can be
     * used, unless its getDisposalMethod() is
     * {@link AnimationDisposalMode#RESTORE_PREVIOUS}.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setRequiredFrame(final int _requiredFrame) {
        this._requiredFrame = _requiredFrame;
        return this;
    }

    /**
     * Number of milliseconds to show this frame.
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setDuration(final int _duration) {
        this._duration = _duration;
        return this;
    }

    /**
     * <p>
     * Whether the end marker for this frame is contained in the stream.
     * </p>
     *
     * <p>
     * Note: this does not guarantee that an attempt to decode will be complete.
     * There could be an error in the stream.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setFullyReceived(final boolean _fullyReceived) {
        this._fullyReceived = _fullyReceived;
        return this;
    }

    /**
     * <p>
     * This is conservative; it will still return non-opaque if e.g. a
     * color index-based frame has a color with alpha but does not use it.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setAlphaType(final ColorAlphaType _alphaType) {
        this._alphaType = _alphaType;
        return this;
    }

    /**
     * <p>
     * Whether the updated rectangle contains alpha.
     * </p>
     *
     * <p>
     * This is conservative; it will still be set to true if e.g. a color
     * index-based frame has a color with alpha but does not use it. In
     * addition, it may be set to true, even if the final frame, after
     * blending, is opaque.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setHasAlphaWithinBounds(final boolean _hasAlphaWithinBounds) {
        this._hasAlphaWithinBounds = _hasAlphaWithinBounds;
        return this;
    }

    /**
     * <p>
     * How this frame should be modified before decoding the next one.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setDisposalMethod(final AnimationDisposalMode _disposalMethod) {
        this._disposalMethod = _disposalMethod;
        return this;
    }

    /**
     * <p>
     * How this frame should blend with the prior frame.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setBlendMode(final BlendMode _blendMode) {
        this._blendMode = _blendMode;
        return this;
    }

    /**
     * <p>
     * The rectangle updated by this frame.
     * </p>
     *
     * <p>
     * It may be empty, if the frame does not change the image. It will
     * always be contained by {@link Codec#getSize()}.
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo setFrameRect(final IRect _frameRect) {
        this._frameRect = _frameRect;
        return this;
    }

    @Override
    @SuppressWarnings("all")
    public boolean equals(final Object o) {
        if (o == this)
            return true;
        if (!(o instanceof AnimationFrameInfo))
            return false;
        final AnimationFrameInfo other = (AnimationFrameInfo) o;
        if (!other.canEqual((Object) this))
            return false;
        if (this.getRequiredFrame() != other.getRequiredFrame())
            return false;
        if (this.getDuration() != other.getDuration())
            return false;
        if (this.isFullyReceived() != other.isFullyReceived())
            return false;
        if (this.isHasAlphaWithinBounds() != other.isHasAlphaWithinBounds())
            return false;
        final Object this$_alphaType = this.getAlphaType();
        final Object other$_alphaType = other.getAlphaType();
        if (this$_alphaType == null ? other$_alphaType != null : !this$_alphaType.equals(other$_alphaType))
            return false;
        final Object this$_disposalMethod = this.getDisposalMethod();
        final Object other$_disposalMethod = other.getDisposalMethod();
        if (this$_disposalMethod == null ? other$_disposalMethod != null
                : !this$_disposalMethod.equals(other$_disposalMethod))
            return false;
        final Object this$_blendMode = this.getBlendMode();
        final Object other$_blendMode = other.getBlendMode();
        if (this$_blendMode == null ? other$_blendMode != null : !this$_blendMode.equals(other$_blendMode))
            return false;
        final Object this$_frameRect = this.getFrameRect();
        final Object other$_frameRect = other.getFrameRect();
        if (this$_frameRect == null ? other$_frameRect != null : !this$_frameRect.equals(other$_frameRect))
            return false;
        return true;
    }

    @SuppressWarnings("all")
    protected boolean canEqual(final Object other) {
        return other instanceof AnimationFrameInfo;
    }

    @Override
    @SuppressWarnings("all")
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        result = result * PRIME + this.getRequiredFrame();
        result = result * PRIME + this.getDuration();
        result = result * PRIME + (this.isFullyReceived() ? 79 : 97);
        result = result * PRIME + (this.isHasAlphaWithinBounds() ? 79 : 97);
        final Object $_alphaType = this.getAlphaType();
        result = result * PRIME + ($_alphaType == null ? 43 : $_alphaType.hashCode());
        final Object $_disposalMethod = this.getDisposalMethod();
        result = result * PRIME + ($_disposalMethod == null ? 43 : $_disposalMethod.hashCode());
        final Object $_blendMode = this.getBlendMode();
        result = result * PRIME + ($_blendMode == null ? 43 : $_blendMode.hashCode());
        final Object $_frameRect = this.getFrameRect();
        result = result * PRIME + ($_frameRect == null ? 43 : $_frameRect.hashCode());
        return result;
    }

    @Override
    @SuppressWarnings("all")
    public String toString() {
        return "AnimationFrameInfo(_requiredFrame=" + this.getRequiredFrame() + ", _duration=" + this.getDuration()
                + ", _fullyReceived=" + this.isFullyReceived() + ", _alphaType=" + this.getAlphaType()
                + ", _hasAlphaWithinBounds=" + this.isHasAlphaWithinBounds() + ", _disposalMethod="
                + this.getDisposalMethod() + ", _blendMode=" + this.getBlendMode() + ", _frameRect="
                + this.getFrameRect() + ")";
    }

    @SuppressWarnings("all")
    public AnimationFrameInfo(final int requiredFrame, final int duration, final boolean fullyReceived,
            final ColorAlphaType alphaType, final boolean hasAlphaWithinBounds,
            final AnimationDisposalMode disposalMethod, final BlendMode blendMode, final IRect frameRect) {
        this._requiredFrame = requiredFrame;
        this._duration = duration;
        this._fullyReceived = fullyReceived;
        this._alphaType = alphaType;
        this._hasAlphaWithinBounds = hasAlphaWithinBounds;
        this._disposalMethod = disposalMethod;
        this._blendMode = blendMode;
        this._frameRect = frameRect;
    }

    /**
     * <p>
     * The frame that this frame needs to be blended with, or
     * -1 if this frame is independent (so it can be
     * drawn over an uninitialized buffer).
     * </p>
     *
     * <p>
     * Note that this is the *earliest* frame that can be used
     * for blending. Any frame from [_requiredFrame, i) can be
     * used, unless its getDisposalMethod() is
     * {@link AnimationDisposalMode#RESTORE_PREVIOUS}.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withRequiredFrame(final int _requiredFrame) {
        return this._requiredFrame == _requiredFrame ? this
                : new AnimationFrameInfo(_requiredFrame, this._duration, this._fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * Number of milliseconds to show this frame.
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withDuration(final int _duration) {
        return this._duration == _duration ? this
                : new AnimationFrameInfo(this._requiredFrame, _duration, this._fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * <p>
     * Whether the end marker for this frame is contained in the stream.
     * </p>
     *
     * <p>
     * Note: this does not guarantee that an attempt to decode will be complete.
     * There could be an error in the stream.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withFullyReceived(final boolean _fullyReceived) {
        return this._fullyReceived == _fullyReceived ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, _fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * <p>
     * This is conservative; it will still return non-opaque if e.g. a
     * color index-based frame has a color with alpha but does not use it.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withAlphaType(final ColorAlphaType _alphaType) {
        return this._alphaType == _alphaType ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, this._fullyReceived, _alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * <p>
     * Whether the updated rectangle contains alpha.
     * </p>
     *
     * <p>
     * This is conservative; it will still be set to true if e.g. a color
     * index-based frame has a color with alpha but does not use it. In
     * addition, it may be set to true, even if the final frame, after
     * blending, is opaque.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withHasAlphaWithinBounds(final boolean _hasAlphaWithinBounds) {
        return this._hasAlphaWithinBounds == _hasAlphaWithinBounds ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, this._fullyReceived, this._alphaType,
                        _hasAlphaWithinBounds, this._disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * <p>
     * How this frame should be modified before decoding the next one.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withDisposalMethod(final AnimationDisposalMode _disposalMethod) {
        return this._disposalMethod == _disposalMethod ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, this._fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, _disposalMethod, this._blendMode, this._frameRect);
    }

    /**
     * <p>
     * How this frame should blend with the prior frame.
     * </p>
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withBlendMode(final BlendMode _blendMode) {
        return this._blendMode == _blendMode ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, this._fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, _blendMode, this._frameRect);
    }

    /**
     * <p>
     * The rectangle updated by this frame.
     * </p>
     *
     * <p>
     * It may be empty, if the frame does not change the image. It will
     * always be contained by {@link Codec#getSize()}.
     *
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public AnimationFrameInfo withFrameRect(final IRect _frameRect) {
        return this._frameRect == _frameRect ? this
                : new AnimationFrameInfo(this._requiredFrame, this._duration, this._fullyReceived, this._alphaType,
                        this._hasAlphaWithinBounds, this._disposalMethod, this._blendMode, _frameRect);
    }
}
